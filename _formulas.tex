\documentclass{article}
\usepackage{ifthen}
\usepackage{epsfig}
\usepackage[utf8]{inputenc}
% Packages requested by user
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{newunicodechar}
  \newunicodechar{⁻}{${}^{-}$}% Superscript minus
  \newunicodechar{²}{${}^{2}$}% Superscript two
  \newunicodechar{³}{${}^{3}$}% Superscript three

\pagestyle{empty}
\begin{document}
$ (C^\infty) $
\pagebreak

$ C^k $
\pagebreak

$ k \geq 0 $
\pagebreak

$k$
\pagebreak

$ C(h) = \sigma^2 \exp(-h) $
\pagebreak

$ \nu = 1/2 $
\pagebreak

$ \gamma = 1 $
\pagebreak

$ C(h) = \sigma^2 \exp(-h^\gamma) $
\pagebreak

$ \gamma = 2 $
\pagebreak

$ C(h) = \sigma^2 \exp(-h^2) \$f, producing smooth sample paths. This is the Matérn covariance function for $
\pagebreak

$, and the gamma-exponential covariance function for $
\pagebreak

$. */ class GaussianCovariance { public: /** @brief Evaluate the covariance function @tparam RF type of values and coordinates @tparam dim dimension of domain @param variance covariance for lag zero @param x location, after scaling / trafo with correlation length @return resulting value */ template<typename RF, long unsigned int dim> RF operator()(const RF variance, const std::array<RF, dim>& x) const { RF sum = 0.; for (unsigned int i = 0; i < dim; i++) sum += x[i] * x[i]; RF h_eff = std::sqrt(sum); return variance * std::exp(-h_eff * h_eff); } }; /** @brief Separable exponential covariance function The separable exponential covariance function is simply the product of one-dimensional exponential covariance functions. */ class SeparableExponentialCovariance { public: /** @brief Evaluate the covariance function @tparam RF type of values and coordinates @tparam dim dimension of domain @param variance covariance for lag zero @param x location, after scaling / trafo with correlation length @return resulting value */ template<typename RF, long unsigned int dim> RF operator()(const RF variance, const std::array<RF, dim>& x) const { RF sum = 0.; for (unsigned int i = 0; i < dim; i++) sum += std::abs(x[i]); RF h_eff = sum; return variance * std::exp(-h_eff); } }; /** @brief Matern covariance function The Matern covariance function family is very popular, since it provides explicit control over the smoothness of the resulting sample paths via its parameter $
\pagebreak

$. The general family requires Bessel functions provided by the GNU Scientific Library (GSL). The special cases $
\pagebreak

$ are provided separately, for use cases where the GSL is unavailable. */ class MaternCovariance { const double nu; const double sqrtTwoNu; const double twoToOneMinusNu; const double gammaNu; public: /** @brief Constructor @param config configuration used for nu */ MaternCovariance(const Dune::ParameterTree& config) : nu(config.template get<double>("stochastic.maternNu")) , sqrtTwoNu(std::sqrt(2. * nu)) , twoToOneMinusNu(std::pow(2., 1. - nu)) , gammaNu(std::tgamma(nu)) { if (nu < 0.) throw std::runtime_error{ "matern nu has to be positive" }; } /** @brief Evaluate the covariance function @tparam RF type of values and coordinates @tparam dim dimension of domain @param variance covariance for lag zero @param x location, after scaling / trafo with correlation length @return resulting value */ template<typename RF, long unsigned int dim> RF operator()(const RF variance, const std::array<RF, dim>& x) const { throw std::runtime_error{ "general matern requires the GNU Scientific Library (gsl)" }; // HAVE_GSL } }; /** @brief Matern covariance function with nu = 3/2 This is a special case of the Matérn covariance function for $
\pagebreak

$, where the function simplifies to $
\pagebreak

$. */ class Matern32Covariance { public: /** @brief Evaluate the covariance function @tparam RF type of values and coordinates @tparam dim dimension of domain @param variance covariance for lag zero @param x location, after scaling / trafo with correlation length @return resulting value */ template<typename RF, long unsigned int dim> RF operator()(const RF variance, const std::array<RF, dim>& x) const { RF sum = 0.; for (unsigned int i = 0; i < dim; i++) sum += x[i] * x[i]; RF h_eff = std::sqrt(sum); return variance * (1. + std::sqrt(3.) * h_eff) * std::exp(-std::sqrt(3.) * h_eff); } }; /** @brief Matern covariance function with nu = 5/2 This is a special case of the Matérn covariance function for $
\pagebreak

$. */ class Matern52Covariance { public: /** @brief Evaluate the covariance function @tparam RF type of values and coordinates @tparam dim dimension of domain @param variance covariance for lag zero @param x location, after scaling / trafo with correlation length @return resulting value */ template<typename RF, long unsigned int dim> RF operator()(const RF variance, const std::array<RF, dim>& x) const { RF sum = 0.; for (unsigned int i = 0; i < dim; i++) sum += x[i] * x[i]; RF h_eff = std::sqrt(sum); return variance * (1. + std::sqrt(5.) * h_eff + 5. / 3. * h_eff * h_eff) * std::exp(-std::sqrt(5.) * h_eff); } }; /** @brief Damped oscillation covariance function This is a damped cosine that decays fast enough so that it remains positive definite. */ class DampedOscillationCovariance { public: /** @brief Evaluate the covariance function @tparam RF type of values and coordinates @tparam dim dimension of domain @param variance covariance for lag zero @param x location, after scaling / trafo with correlation length @return resulting value */ template<typename RF, long unsigned int dim> RF operator()(const RF variance, const std::array<RF, dim>& x) const { RF sum = 0.; for (unsigned int i = 0; i < dim; i++) sum += x[i] * x[i]; RF h_eff = std::sqrt(sum); if (dim == 3) return variance * std::exp(-h_eff) * std::cos(h_eff / std::sqrt(3.)); else return variance * std::exp(-h_eff) * std::cos(h_eff); } }; /** @brief Cauchy covariance function The Cauchy covariance function is \$f C(h) = {(1 + h^2)}^{-3} $
\pagebreak

$ C(h) = {(1 + h^\alpha)}^{-\beta} $
\pagebreak

$ d \times d $
\pagebreak

\end{document}
