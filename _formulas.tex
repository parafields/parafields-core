\documentclass{article}
\usepackage{ifthen}
\usepackage{epsfig}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
% Packages requested by user
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{newunicodechar}
  \makeatletter
    \def\doxynewunicodechar#1#2{%
    \@tempswafalse
    \edef\nuc@tempa{\detokenize{#1}}%
    \if\relax\nuc@tempa\relax
      \nuc@emptyargerr
    \else
      \edef\@tempb{\expandafter\@car\nuc@tempa\@nil}%
      \nuc@check
      \if@tempswa
        \@namedef{u8:\nuc@tempa}{#2}%
      \fi
    \fi
  }
  \makeatother
  \doxynewunicodechar{⁻}{${}^{-}$}% Superscript minus
  \doxynewunicodechar{²}{${}^{2}$}% Superscript two
  \doxynewunicodechar{³}{${}^{3}$}% Superscript three

\pagestyle{empty}
\begin{document}
$ (C^\infty) $
\pagebreak

$ C^k $
\pagebreak

$ k \geq 0 $
\pagebreak

$k$
\pagebreak

$ C(h) = \sigma^2 \exp(-h) $
\pagebreak

$ \nu = 1/2 $
\pagebreak

$ \gamma = 1 $
\pagebreak

$ C(h) = \sigma^2 \exp(-h^\gamma) $
\pagebreak

$ \gamma = 2 $
\pagebreak

$ C(h) = \sigma^2 \exp(-h^2) \$f, producing smooth sample paths.
   This is the Matérn covariance function for $
\pagebreak

$,
   and the gamma-exponential covariance function for $
\pagebreak

$.
 */
class GaussianCovariance
{
public:
  /**
     @brief Evaluate the covariance function
    
     @tparam RF      type of values and coordinates
     @tparam dim     dimension of domain
    
     @param variance covariance for lag zero
     @param x        location, after scaling / trafo with correlation length
    
     @return resulting value
   */
  template<typename RF, long unsigned int dim>
  RF operator()(const RF variance, const std::array<RF, dim>& x) const
  {
    RF sum = 0.;
    for (unsigned int i = 0; i < dim; i++)
      sum += x[i] * x[i];
    RF h_eff = std::sqrt(sum);

    return variance * std::exp(-h_eff * h_eff);
  }
};

/**
   @brief Separable exponential covariance function
  
   The separable exponential covariance function is simply the
   product of one-dimensional exponential covariance functions.
 */
class SeparableExponentialCovariance
{
public:
  /**
     @brief Evaluate the covariance function
    
     @tparam RF      type of values and coordinates
     @tparam dim     dimension of domain
    
     @param variance covariance for lag zero
     @param x        location, after scaling / trafo with correlation length
    
     @return resulting value
   */
  template<typename RF, long unsigned int dim>
  RF operator()(const RF variance, const std::array<RF, dim>& x) const
  {
    RF sum = 0.;
    for (unsigned int i = 0; i < dim; i++)
      sum += std::abs(x[i]);
    RF h_eff = sum;

    return variance * std::exp(-h_eff);
  }
};

/**
   @brief Matern covariance function
  
   The Matern covariance function family is very popular,
   since it provides explicit control over the smoothness
   of the resulting sample paths via its parameter
   $
\pagebreak

$. The general family requires Bessel functions
   provided by the GNU Scientific Library (GSL). The
   special cases $
\pagebreak

$ are provided
   separately, for use cases where the GSL is unavailable.
 */
class MaternCovariance
{
  const double nu;
  const double sqrtTwoNu;
  const double twoToOneMinusNu;
  const double gammaNu;

public:
  /**
     @brief Constructor
    
     @param config configuration used for nu
   */
  MaternCovariance(const Dune::ParameterTree& config)
    : nu(config.template get<double>("stochastic.maternNu"))
    , sqrtTwoNu(std::sqrt(2. * nu))
    , twoToOneMinusNu(std::pow(2., 1. - nu))
    , gammaNu(std::tgamma(nu))
  {
    if (nu < 0.)
      throw std::runtime_error{ "matern nu has to be positive" };
  }

  /**
     @brief Evaluate the covariance function
    
     @tparam RF      type of values and coordinates
     @tparam dim     dimension of domain
    
     @param variance covariance for lag zero
     @param x        location, after scaling / trafo with correlation length
    
     @return resulting value
   */
  template<typename RF, long unsigned int dim>
  RF operator()(const RF variance, const std::array<RF, dim>& x) const
  {
#if HAVE_GSL
    RF sum = 0.;
    for (unsigned int i = 0; i < dim; i++)
      sum += x[i] * x[i];
    RF h_eff = std::sqrt(sum);

    if (h_eff < 1e-10)
      return variance;
    else
      return variance * twoToOneMinusNu / gammaNu *
             std::pow(sqrtTwoNu * h_eff, nu) *
             gsl_sf_bessel_Knu(nu, sqrtTwoNu * h_eff);
#else
    throw std::runtime_error{
      "general matern requires the GNU Scientific Library (gsl)"
    };
#endif // HAVE_GSL
  }
};

/**
   @brief Matern covariance function with nu = 3/2
  
   This is a special case of the Matérn covariance function for
   $
\pagebreak

$, where the function simplifies to
   $
\pagebreak

$.
 */
class Matern32Covariance
{
public:
  /**
     @brief Evaluate the covariance function
    
     @tparam RF      type of values and coordinates
     @tparam dim     dimension of domain
    
     @param variance covariance for lag zero
     @param x        location, after scaling / trafo with correlation length
    
     @return resulting value
   */
  template<typename RF, long unsigned int dim>
  RF operator()(const RF variance, const std::array<RF, dim>& x) const
  {
    RF sum = 0.;
    for (unsigned int i = 0; i < dim; i++)
      sum += x[i] * x[i];
    RF h_eff = std::sqrt(sum);

    return variance * (1. + std::sqrt(3.) * h_eff) *
           std::exp(-std::sqrt(3.) * h_eff);
  }
};

/**
   @brief Matern covariance function with nu = 5/2
  
   This is a special case of the Matérn covariance function for
   $
\pagebreak

$.
 */
class Matern52Covariance
{
public:
  /**
     @brief Evaluate the covariance function
    
     @tparam RF      type of values and coordinates
     @tparam dim     dimension of domain
    
     @param variance covariance for lag zero
     @param x        location, after scaling / trafo with correlation length
    
     @return resulting value
   */
  template<typename RF, long unsigned int dim>
  RF operator()(const RF variance, const std::array<RF, dim>& x) const
  {
    RF sum = 0.;
    for (unsigned int i = 0; i < dim; i++)
      sum += x[i] * x[i];
    RF h_eff = std::sqrt(sum);

    return variance * (1. + std::sqrt(5.) * h_eff + 5. / 3. * h_eff * h_eff) *
           std::exp(-std::sqrt(5.) * h_eff);
  }
};

/**
   @brief Damped oscillation covariance function
  
   This is a damped cosine that decays fast enough so that
   it remains positive definite.
 */
class DampedOscillationCovariance
{
public:
  /**
     @brief Evaluate the covariance function
    
     @tparam RF      type of values and coordinates
     @tparam dim     dimension of domain
    
     @param variance covariance for lag zero
     @param x        location, after scaling / trafo with correlation length
    
     @return resulting value
   */
  template<typename RF, long unsigned int dim>
  RF operator()(const RF variance, const std::array<RF, dim>& x) const
  {
    RF sum = 0.;
    for (unsigned int i = 0; i < dim; i++)
      sum += x[i] * x[i];
    RF h_eff = std::sqrt(sum);

    if (dim == 3)
      return variance * std::exp(-h_eff) * std::cos(h_eff / std::sqrt(3.));
    else
      return variance * std::exp(-h_eff) * std::cos(h_eff);
  }
};

/**
   @brief Cauchy covariance function
  
   The Cauchy covariance function is \$f C(h) = {(1 + h^2)}^{-3} $
\pagebreak

$ C(h) = {(1 + h^\alpha)}^{-\beta} $
\pagebreak

$ d \times d $
\pagebreak

\end{document}
