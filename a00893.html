<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>parafields-core: parafields::DCTMatrixBackend&lt; Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">parafields-core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00069.html">parafields</a></li><li class="navelem"><a class="el" href="a00893.html">DCTMatrixBackend</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00890.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parafields::DCTMatrixBackend&lt; Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a01009.html" title="Covariance matrix for stationary Gaussian random fields.">Matrix</a> backend that uses discrete cosine transform (DCT)  
 <a href="a00893.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00008_source.html">dctmatrixbackend.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad6759944da6fc8a4366e0a4e126c1994"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#ad6759944da6fc8a4366e0a4e126c1994">DCTMatrixBackend</a> (const std::shared_ptr&lt; Traits &gt; &amp;traits_)</td></tr>
<tr class="memdesc:ad6759944da6fc8a4366e0a4e126c1994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a00893.html#ad6759944da6fc8a4366e0a4e126c1994">More...</a><br /></td></tr>
<tr class="separator:ad6759944da6fc8a4366e0a4e126c1994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2336cf92ab892ca68c2d23b5f51a2c02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a2336cf92ab892ca68c2d23b5f51a2c02">~DCTMatrixBackend</a> ()</td></tr>
<tr class="memdesc:a2336cf92ab892ca68c2d23b5f51a2c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="a00893.html#a2336cf92ab892ca68c2d23b5f51a2c02">More...</a><br /></td></tr>
<tr class="separator:a2336cf92ab892ca68c2d23b5f51a2c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a13e01feb1cf336d137298ad2937ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#ad1a13e01feb1cf336d137298ad2937ce">update</a> ()</td></tr>
<tr class="separator:ad1a13e01feb1cf336d137298ad2937ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93355fefb3fd605694197f0cb9fc0178"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a93355fefb3fd605694197f0cb9fc0178">valid</a> () const</td></tr>
<tr class="memdesc:a93355fefb3fd605694197f0cb9fc0178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether matrix has already been created.  <a href="a00893.html#a93355fefb3fd605694197f0cb9fc0178">More...</a><br /></td></tr>
<tr class="separator:a93355fefb3fd605694197f0cb9fc0178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21c2c473a56c87cac0e73434a7eda05"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#ad21c2c473a56c87cac0e73434a7eda05">localMatrixSize</a> () const</td></tr>
<tr class="memdesc:ad21c2c473a56c87cac0e73434a7eda05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of matrix entries stored on this processor.  <a href="a00893.html#ad21c2c473a56c87cac0e73434a7eda05">More...</a><br /></td></tr>
<tr class="separator:ad21c2c473a56c87cac0e73434a7eda05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1e8dcdf56f96949f1e29964ca596bc"><td class="memItemLeft" align="right" valign="top">const Indices &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#aee1e8dcdf56f96949f1e29964ca596bc">localMatrixCells</a> () const</td></tr>
<tr class="memdesc:aee1e8dcdf56f96949f1e29964ca596bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries per dim on this processor.  <a href="a00893.html#aee1e8dcdf56f96949f1e29964ca596bc">More...</a><br /></td></tr>
<tr class="separator:aee1e8dcdf56f96949f1e29964ca596bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cee0611402eb93413adcc736d7ca5fa"><td class="memItemLeft" align="right" valign="top">const Indices &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a5cee0611402eb93413adcc736d7ca5fa">localMatrixOffset</a> () const</td></tr>
<tr class="memdesc:a5cee0611402eb93413adcc736d7ca5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset between local indices and global indices per dim.  <a href="a00893.html#a5cee0611402eb93413adcc736d7ca5fa">More...</a><br /></td></tr>
<tr class="separator:a5cee0611402eb93413adcc736d7ca5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43870d9a2b1048b4a5e192fd6f5f2f9"><td class="memItemLeft" align="right" valign="top">const Indices &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#ab43870d9a2b1048b4a5e192fd6f5f2f9">localEvalMatrixCells</a> () const</td></tr>
<tr class="memdesc:ab43870d9a2b1048b4a5e192fd6f5f2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of logical entries per dim on this processor.  <a href="a00893.html#ab43870d9a2b1048b4a5e192fd6f5f2f9">More...</a><br /></td></tr>
<tr class="separator:ab43870d9a2b1048b4a5e192fd6f5f2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1c94fdbbbfbf93ef655bf213c517c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a6e1c94fdbbbfbf93ef655bf213c517c1">allocate</a> ()</td></tr>
<tr class="memdesc:a6e1c94fdbbbfbf93ef655bf213c517c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory before storing any matrix entries.  <a href="a00893.html#a6e1c94fdbbbfbf93ef655bf213c517c1">More...</a><br /></td></tr>
<tr class="separator:a6e1c94fdbbbfbf93ef655bf213c517c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f0974ba5dfd6e02318b2ff1b2cd657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a45f0974ba5dfd6e02318b2ff1b2cd657">transposeIfNeeded</a> (ptrdiff_t &amp;localN0, ptrdiff_t &amp;local0Start)</td></tr>
<tr class="memdesc:a45f0974ba5dfd6e02318b2ff1b2cd657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch last two dimensions (for transposed transforms)  <a href="a00893.html#a45f0974ba5dfd6e02318b2ff1b2cd657">More...</a><br /></td></tr>
<tr class="separator:a45f0974ba5dfd6e02318b2ff1b2cd657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456d9fda9a63b9ea9db32740b92f2838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a456d9fda9a63b9ea9db32740b92f2838">forwardTransform</a> ()</td></tr>
<tr class="memdesc:a456d9fda9a63b9ea9db32740b92f2838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform into Fourier (i.e., frequency) space.  <a href="a00893.html#a456d9fda9a63b9ea9db32740b92f2838">More...</a><br /></td></tr>
<tr class="separator:a456d9fda9a63b9ea9db32740b92f2838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828ef3d54d1225da3cd7a387302b1559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a828ef3d54d1225da3cd7a387302b1559">backwardTransform</a> ()</td></tr>
<tr class="memdesc:a828ef3d54d1225da3cd7a387302b1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform from Fourier (i.e., frequency) space.  <a href="a00893.html#a828ef3d54d1225da3cd7a387302b1559">More...</a><br /></td></tr>
<tr class="separator:a828ef3d54d1225da3cd7a387302b1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe1a40e845d69bacd64047ffe2fee23"><td class="memItemLeft" align="right" valign="top">RF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a3fe1a40e845d69bacd64047ffe2fee23">eval</a> (Index index) const</td></tr>
<tr class="memdesc:a3fe1a40e845d69bacd64047ffe2fee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate matrix entry (in virtual, i.e., logical indices)  <a href="a00893.html#a3fe1a40e845d69bacd64047ffe2fee23">More...</a><br /></td></tr>
<tr class="separator:a3fe1a40e845d69bacd64047ffe2fee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65794721a6cca2afe7b4634507cc77e"><td class="memItemLeft" align="right" valign="top">RF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#aa65794721a6cca2afe7b4634507cc77e">eval</a> (Indices indices) const</td></tr>
<tr class="memdesc:aa65794721a6cca2afe7b4634507cc77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate matrix entry (in virtual, i.e., logical indices)  <a href="a00893.html#aa65794721a6cca2afe7b4634507cc77e">More...</a><br /></td></tr>
<tr class="separator:aa65794721a6cca2afe7b4634507cc77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ddaa43c0315848a9eb413ae53b80a"><td class="memItemLeft" align="right" valign="top">RF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a125ddaa43c0315848a9eb413ae53b80a">get</a> (Index index) const</td></tr>
<tr class="memdesc:a125ddaa43c0315848a9eb413ae53b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get matrix entry (using the actual index)  <a href="a00893.html#a125ddaa43c0315848a9eb413ae53b80a">More...</a><br /></td></tr>
<tr class="separator:a125ddaa43c0315848a9eb413ae53b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010d59c49c5d24d4c4e8bff01a59b0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#a010d59c49c5d24d4c4e8bff01a59b0a6">set</a> (Index index, RF value)</td></tr>
<tr class="memdesc:a010d59c49c5d24d4c4e8bff01a59b0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix entry (using the actual index)  <a href="a00893.html#a010d59c49c5d24d4c4e8bff01a59b0a6">More...</a><br /></td></tr>
<tr class="separator:a010d59c49c5d24d4c4e8bff01a59b0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadec9c5c3b16499d10a44ac0c94bc8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00893.html#aadec9c5c3b16499d10a44ac0c94bc8b4">finalize</a> ()</td></tr>
<tr class="memdesc:aadec9c5c3b16499d10a44ac0c94bc8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mirror matrix on domain boundary in parallel case.  <a href="a00893.html#aadec9c5c3b16499d10a44ac0c94bc8b4">More...</a><br /></td></tr>
<tr class="separator:aadec9c5c3b16499d10a44ac0c94bc8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Traits&gt;<br />
class parafields::DCTMatrixBackend&lt; Traits &gt;</h3>

<p><a class="el" href="a01009.html" title="Covariance matrix for stationary Gaussian random fields.">Matrix</a> backend that uses discrete cosine transform (DCT) </p>
<p>This matrix backend implements the circulant embedding method for covariance functions with axial symmetries, i.e., functions for which flipping the sign in one of the dimensions of the argument doesn't change the function value. This is the case, e.g., for isotropic, axially anisotropic, and separable covariance functions, and combinations thereof. These additional symmetries make it possible to reduce the number of cells by a factor of two in each dimension. In cases where the minimum embedding factor of two is sufficient, the data on the extended domain can be represented on the original domain with one row of cells per dimension as padding.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>traits class with data types and definitions </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad6759944da6fc8a4366e0a4e126c1994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6759944da6fc8a4366e0a4e126c1994">&#9670;&nbsp;</a></span>DCTMatrixBackend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::<a class="el" href="a00893.html">DCTMatrixBackend</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>traits_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Imports <a class="el" href="a00905.html" title="Fallback class for error message when requested FFTW3 library wasn&#39;t found.">FFTW</a> wisdom if configured to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traits_</td><td>traits object with parameters and communication </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2336cf92ab892ca68c2d23b5f51a2c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2336cf92ab892ca68c2d23b5f51a2c02">&#9670;&nbsp;</a></span>~DCTMatrixBackend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::~<a class="el" href="a00893.html">DCTMatrixBackend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Cleans up allocated arrays and <a class="el" href="a00905.html" title="Fallback class for error message when requested FFTW3 library wasn&#39;t found.">FFTW</a> plans. Exports <a class="el" href="a00905.html" title="Fallback class for error message when requested FFTW3 library wasn&#39;t found.">FFTW</a> wisdom if configured to do so. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e1c94fdbbbfbf93ef655bf213c517c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1c94fdbbbfbf93ef655bf213c517c1">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve memory before storing any matrix entries. </p>
<p>Explicitly request the matrix backend to reserve storage for the multidimensional array. This ensures that the backend doesn't waste memory when it won't be used. </p>

</div>
</div>
<a id="a828ef3d54d1225da3cd7a387302b1559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828ef3d54d1225da3cd7a387302b1559">&#9670;&nbsp;</a></span>backwardTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::backwardTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform from Fourier (i.e., frequency) space. </p>
<p>Perform a backward Fourier transform, mapping from the frequency domain back to the original domain. Uses a single <a class="el" href="a00905.html" title="Fallback class for error message when requested FFTW3 library wasn&#39;t found.">FFTW</a> real-to-real DFT transform. </p>

</div>
</div>
<a id="a3fe1a40e845d69bacd64047ffe2fee23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe1a40e845d69bacd64047ffe2fee23">&#9670;&nbsp;</a></span>eval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RF <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::eval </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate matrix entry (in virtual, i.e., logical indices) </p>
<p>This function returns the matrix entry associated with the given local index (i.e., index for the local part of the array for the extended domain). Half of the entries per dimension are not actually stored, since they are redundant. Therefore, this function has to convert its argument into the corresponding index that actually has data associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>flat index for the local array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value associated with index </dd></dl>

</div>
</div>
<a id="aa65794721a6cca2afe7b4634507cc77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65794721a6cca2afe7b4634507cc77e">&#9670;&nbsp;</a></span>eval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RF <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::eval </td>
          <td>(</td>
          <td class="paramtype">Indices&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate matrix entry (in virtual, i.e., logical indices) </p>
<p>This function returns the matrix entry associated with the given local indices (i.e., tuple of indices for the local part of the array for the extended domain, taking possible offsets into account). In each dimension, half of the entries are not actually stored, since they are redundant. This function takes care of this and maps any such tuple of indices to the corresponding index tuple that actually has data associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>tuple of local indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value associated with indices </dd></dl>

</div>
</div>
<a id="aadec9c5c3b16499d10a44ac0c94bc8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadec9c5c3b16499d10a44ac0c94bc8b4">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mirror matrix on domain boundary in parallel case. </p>
<p>This function takes the transformed array and mirrors the distributed dimension on the domain boundary in the parallel case, i.e., It reverts the savings gained by using the underlying symmetry in this one dimension, and the size of the array grows by roughly a factor of two. This is needed for parallel field generation, because otherwise the data for some of the cells would lie on another processor and couldn't be accessed. After this function has been called, the backend can no longer be modified. </p>

</div>
</div>
<a id="a456d9fda9a63b9ea9db32740b92f2838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456d9fda9a63b9ea9db32740b92f2838">&#9670;&nbsp;</a></span>forwardTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::forwardTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform into Fourier (i.e., frequency) space. </p>
<p>Perform a forward Fourier transform, mapping from the original domain to the frequency domain. Uses a single <a class="el" href="a00905.html" title="Fallback class for error message when requested FFTW3 library wasn&#39;t found.">FFTW</a> real-to-real DFT transform. </p>

</div>
</div>
<a id="a125ddaa43c0315848a9eb413ae53b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ddaa43c0315848a9eb413ae53b80a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RF <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get matrix entry (using the actual index) </p>
<p>This function returns the entry of the array associated with the given index. It uses the actual index of the untransformed array, and may not be used after the matrix backend has been finalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>flat index for the local array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value associated with index</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00893.html#a3fe1a40e845d69bacd64047ffe2fee23" title="Evaluate matrix entry (in virtual, i.e., logical indices)">eval</a> </dd>
<dd>
<a class="el" href="a00893.html#aadec9c5c3b16499d10a44ac0c94bc8b4" title="Mirror matrix on domain boundary in parallel case.">finalize</a> </dd></dl>

</div>
</div>
<a id="ab43870d9a2b1048b4a5e192fd6f5f2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43870d9a2b1048b4a5e192fd6f5f2f9">&#9670;&nbsp;</a></span>localEvalMatrixCells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Indices&amp; <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::localEvalMatrixCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of logical entries per dim on this processor. </p>
<p>This is the number of entries that the local array represents. For the given backend, this is approximately half the number of cells of the extended domain in each dimension, except for parallel runs, where the distributed dimension is mirrored to make the entries locally available on the correct processors. </p>

</div>
</div>
<a id="aee1e8dcdf56f96949f1e29964ca596bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1e8dcdf56f96949f1e29964ca596bc">&#9670;&nbsp;</a></span>localMatrixCells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Indices&amp; <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::localMatrixCells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of entries per dim on this processor. </p>
<p>This is the number of cells per dimension of the extended domain, or the number of cells per dimension for the local part of the extended domain in the case of parallel data distribution.</p>
<dl class="section return"><dt>Returns</dt><dd>tuple of local cells per dimension </dd></dl>

</div>
</div>
<a id="a5cee0611402eb93413adcc736d7ca5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cee0611402eb93413adcc736d7ca5fa">&#9670;&nbsp;</a></span>localMatrixOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Indices&amp; <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::localMatrixOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset between local indices and global indices per dim. </p>
<p>This is the tuple of offsets, one per dimension, between the start of the local array and the start of the global array spanning all processors.</p>
<dl class="section return"><dt>Returns</dt><dd>tuple of offsets </dd></dl>

</div>
</div>
<a id="ad21c2c473a56c87cac0e73434a7eda05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21c2c473a56c87cac0e73434a7eda05">&#9670;&nbsp;</a></span>localMatrixSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::localMatrixSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of matrix entries stored on this processor. </p>
<p>This is the size of the extended domain, or its local subset in the case of parallel data distribution. For this backend, it is the size of the original domain plus a small amount needed for padding.</p>
<dl class="section return"><dt>Returns</dt><dd>number of local degrees of freedom </dd></dl>

</div>
</div>
<a id="a010d59c49c5d24d4c4e8bff01a59b0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010d59c49c5d24d4c4e8bff01a59b0a6">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RF&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set matrix entry (using the actual index) </p>
<p>This function sets the entry of the array associated with the given index. It uses the actual index of the untransformed array, and may not be used after the matrix backend has been finalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>flat index for the local array </td></tr>
    <tr><td class="paramname">value</td><td>value that should be associated with the index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00893.html#aadec9c5c3b16499d10a44ac0c94bc8b4" title="Mirror matrix on domain boundary in parallel case.">finalize</a> </dd></dl>

</div>
</div>
<a id="a45f0974ba5dfd6e02318b2ff1b2cd657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f0974ba5dfd6e02318b2ff1b2cd657">&#9670;&nbsp;</a></span>transposeIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::transposeIfNeeded </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t &amp;&#160;</td>
          <td class="paramname"><em>localN0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t &amp;&#160;</td>
          <td class="paramname"><em>local0Start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch last two dimensions (for transposed transforms) </p>
<p>This function switches the last two dimensions, which is needed for <a class="el" href="a00905.html" title="Fallback class for error message when requested FFTW3 library wasn&#39;t found.">FFTW</a> transposed transforms, where the Fourier transform of the matrix is stored transposed to eliminate the final transpose step. Is automatically called by the transform methods, but may be needed when a newly created backend should be constructed directly in frequency space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localN0</td><td>current number of cells in distributed dimension </td></tr>
    <tr><td class="paramname">local0Start</td><td>current offset in distributed dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1a13e01feb1cf336d137298ad2937ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a13e01feb1cf336d137298ad2937ce">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93355fefb3fd605694197f0cb9fc0178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93355fefb3fd605694197f0cb9fc0178">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00893.html">parafields::DCTMatrixBackend</a>&lt; Traits &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether matrix has already been created. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the matrix data is present, else false </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00008_source.html">dctmatrixbackend.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
