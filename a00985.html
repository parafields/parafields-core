<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>parafields-core: parafields::RandomField&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">parafields-core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00069.html">parafields</a></li><li class="navelem"><a class="el" href="a00985.html">RandomField</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a00982.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parafields::RandomField&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Gaussian random field in arbitrary dimensions.  
 <a href="a00985.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00059_source.html">randomfield.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01069.html">ParamTreeHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class for ParameterTree value extraction.  <a href="a01069.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acca23b257b56b7e0a750f0d3de85bb8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> = <a class="el" href="a00989.html">RandomFieldTraits</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;</td></tr>
<tr class="separator:acca23b257b56b7e0a750f0d3de85bb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51200ef46e2f3ad0374f86d9b5b12b1b"><td class="memTemplParams" colspan="2">template&lt;typename LoadBalance  = DefaultLoadBalance&lt;GridTraits::dim&gt;&gt; </td></tr>
<tr class="memitem:a51200ef46e2f3ad0374f86d9b5b12b1b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00985.html#a51200ef46e2f3ad0374f86d9b5b12b1b">RandomField</a> (const Dune::ParameterTree &amp;config_, const std::string &amp;fileName=&quot;&quot;, const LoadBalance &amp;loadBalance=LoadBalance(), const MPI_Comm comm=MPI_COMM_WORLD)</td></tr>
<tr class="memdesc:a51200ef46e2f3ad0374f86d9b5b12b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor reading from file or creating homogeneous field.  <a href="a00985.html#a51200ef46e2f3ad0374f86d9b5b12b1b">More...</a><br /></td></tr>
<tr class="separator:a51200ef46e2f3ad0374f86d9b5b12b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fe6c63e1a77b60f7e94f6f9911561d"><td class="memTemplParams" colspan="2">template&lt;typename LoadBalance  = DefaultLoadBalance&lt;GridTraits::dim&gt;&gt; </td></tr>
<tr class="memitem:ac9fe6c63e1a77b60f7e94f6f9911561d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00985.html#ac9fe6c63e1a77b60f7e94f6f9911561d">RandomField</a> (const std::string &amp;fileName, const LoadBalance &amp;loadBalance=LoadBalance(), const MPI_Comm comm=MPI_COMM_WORLD)</td></tr>
<tr class="memdesc:ac9fe6c63e1a77b60f7e94f6f9911561d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor reading field and config from file.  <a href="a00985.html#ac9fe6c63e1a77b60f7e94f6f9911561d">More...</a><br /></td></tr>
<tr class="separator:ac9fe6c63e1a77b60f7e94f6f9911561d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf1a4716435e0720ac1058eb4ee14b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a22cf1a4716435e0720ac1058eb4ee14b">RandomField</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other, const std::string &amp;fileName)</td></tr>
<tr class="memdesc:a22cf1a4716435e0720ac1058eb4ee14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor copying traits and covariance matrix.  <a href="a00985.html#a22cf1a4716435e0720ac1058eb4ee14b">More...</a><br /></td></tr>
<tr class="separator:a22cf1a4716435e0720ac1058eb4ee14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dabb17e572535d26dbaa329e222e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ac6dabb17e572535d26dbaa329e222e69">RandomField</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other)</td></tr>
<tr class="memdesc:ac6dabb17e572535d26dbaa329e222e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="a00985.html#ac6dabb17e572535d26dbaa329e222e69">More...</a><br /></td></tr>
<tr class="separator:ac6dabb17e572535d26dbaa329e222e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ec552787cd55d6c28ac6006a66b395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html">RandomField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a80ec552787cd55d6c28ac6006a66b395">operator=</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other)</td></tr>
<tr class="memdesc:a80ec552787cd55d6c28ac6006a66b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="a00985.html#a80ec552787cd55d6c28ac6006a66b395">More...</a><br /></td></tr>
<tr class="separator:a80ec552787cd55d6c28ac6006a66b395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929c32bce4c82ed36d4e09bc586f5441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a929c32bce4c82ed36d4e09bc586f5441">cellVolume</a> () const</td></tr>
<tr class="memdesc:a929c32bce4c82ed36d4e09bc586f5441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell volume of the random field discretization.  <a href="a00985.html#a929c32bce4c82ed36d4e09bc586f5441">More...</a><br /></td></tr>
<tr class="separator:a929c32bce4c82ed36d4e09bc586f5441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe8a51ea400b1a354a42d06ef6797f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#adcbe8a51ea400b1a354a42d06ef6797f">dofs</a> () const</td></tr>
<tr class="memdesc:adcbe8a51ea400b1a354a42d06ef6797f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of degrees of freedom.  <a href="a00985.html#adcbe8a51ea400b1a354a42d06ef6797f">More...</a><br /></td></tr>
<tr class="separator:adcbe8a51ea400b1a354a42d06ef6797f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9368238afb78bf7292007054ee89bae"><td class="memTemplParams" colspan="2">template&lt;typename Covariance &gt; </td></tr>
<tr class="memitem:ab9368238afb78bf7292007054ee89bae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00985.html#ab9368238afb78bf7292007054ee89bae">fillMatrix</a> (Covariance &amp;&amp;covariance)</td></tr>
<tr class="memdesc:ab9368238afb78bf7292007054ee89bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit matrix setup for custom covariance classes.  <a href="a00985.html#ab9368238afb78bf7292007054ee89bae">More...</a><br /></td></tr>
<tr class="separator:ab9368238afb78bf7292007054ee89bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ea63a8f1baae4662baa090d81b3e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a06ea63a8f1baae4662baa090d81b3e29">add_trend_components</a> (const Dune::ParameterTree &amp;<a class="el" href="a00985.html#ad65014826513fd13d3f3a82a89b25aef">config</a>)</td></tr>
<tr class="memdesc:a06ea63a8f1baae4662baa090d81b3e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically add trend components.  <a href="a00985.html#a06ea63a8f1baae4662baa090d81b3e29">More...</a><br /></td></tr>
<tr class="separator:a06ea63a8f1baae4662baa090d81b3e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc300906c9a778530dda47cbd9fe0165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#afc300906c9a778530dda47cbd9fe0165">remove_trend_components</a> (std::size_t count)</td></tr>
<tr class="memdesc:afc300906c9a778530dda47cbd9fe0165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically remove a number of trend components.  <a href="a00985.html#afc300906c9a778530dda47cbd9fe0165">More...</a><br /></td></tr>
<tr class="separator:afc300906c9a778530dda47cbd9fe0165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81946963b8d1625f5733818bed4a3d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ae81946963b8d1625f5733818bed4a3d6">generate</a> (bool allowNonWorldComm=false)</td></tr>
<tr class="memdesc:ae81946963b8d1625f5733818bed4a3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a field with the desired correlation structure.  <a href="a00985.html#ae81946963b8d1625f5733818bed4a3d6">More...</a><br /></td></tr>
<tr class="separator:ae81946963b8d1625f5733818bed4a3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c7ad192dd132719c589ddcea0105c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a07c7ad192dd132719c589ddcea0105c9">generate</a> (unsigned int seed, bool allowNonWorldComm=false)</td></tr>
<tr class="memdesc:a07c7ad192dd132719c589ddcea0105c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a field with desired correlation structure using seed.  <a href="a00985.html#a07c7ad192dd132719c589ddcea0105c9">More...</a><br /></td></tr>
<tr class="separator:a07c7ad192dd132719c589ddcea0105c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ab19539c808298edf6e2325408ed50"><td class="memTemplParams" colspan="2">template&lt;typename RNG &gt; </td></tr>
<tr class="memitem:ac2ab19539c808298edf6e2325408ed50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00985.html#ac2ab19539c808298edf6e2325408ed50">generateWithRNG</a> (RNG &amp;rngBackend, bool allowNonWorldComm=false)</td></tr>
<tr class="memdesc:ac2ab19539c808298edf6e2325408ed50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a field with desired correlation structure using instantiate RNG.  <a href="a00985.html#ac2ab19539c808298edf6e2325408ed50">More...</a><br /></td></tr>
<tr class="separator:ac2ab19539c808298edf6e2325408ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46b87d96023684d6929ba5c6dca8ff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#aa46b87d96023684d6929ba5c6dca8ff3">generateUncorrelated</a> (bool allowNonWorldComm=false)</td></tr>
<tr class="memdesc:aa46b87d96023684d6929ba5c6dca8ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a field without correlation structure (i.e. noise)  <a href="a00985.html#aa46b87d96023684d6929ba5c6dca8ff3">More...</a><br /></td></tr>
<tr class="separator:aa46b87d96023684d6929ba5c6dca8ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b09ed07a309172dbac18497994d9db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a8b09ed07a309172dbac18497994d9db8">generateUncorrelated</a> (unsigned int seed, bool allowNonWorldComm=false)</td></tr>
<tr class="memdesc:a8b09ed07a309172dbac18497994d9db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a field containing noise using seed.  <a href="a00985.html#a8b09ed07a309172dbac18497994d9db8">More...</a><br /></td></tr>
<tr class="separator:a8b09ed07a309172dbac18497994d9db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f04d48116cf25235548e9cb3936fe4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a6f04d48116cf25235548e9cb3936fe4c">evaluate</a> (const typename <a class="el" href="a00989.html#af4edd3b08ecbdde3bc7cea5265213f18">Traits::DomainType</a> &amp;location, typename <a class="el" href="a00989.html#a15dfd27a422f62fc01e88ddb0e0e9906">Traits::RangeType</a> &amp;output) const</td></tr>
<tr class="memdesc:a6f04d48116cf25235548e9cb3936fe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the random field at given coordinates.  <a href="a00985.html#a6f04d48116cf25235548e9cb3936fe4c">More...</a><br /></td></tr>
<tr class="separator:a6f04d48116cf25235548e9cb3936fe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e76474a5b59ce685e5a8f26dadae6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a8e76474a5b59ce685e5a8f26dadae6e4">bulkEvaluate</a> (std::vector&lt; typename <a class="el" href="a00989.html#a15dfd27a422f62fc01e88ddb0e0e9906">Traits::RangeType</a> &gt; &amp;output, typename <a class="el" href="a00989.html#a2826921d7c632bbfff497e3b51e480f1">Traits::Indices</a> &amp;sizes) const</td></tr>
<tr class="memdesc:a8e76474a5b59ce685e5a8f26dadae6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the random field at all cells on this processor.  <a href="a00985.html#a8e76474a5b59ce685e5a8f26dadae6e4">More...</a><br /></td></tr>
<tr class="separator:a8e76474a5b59ce685e5a8f26dadae6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c9f0b0ac803329bc4d573969276e26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#af8c9f0b0ac803329bc4d573969276e26">writeToFile</a> (const std::string &amp;fileName) const</td></tr>
<tr class="memdesc:af8c9f0b0ac803329bc4d573969276e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export random field to files on disk.  <a href="a00985.html#af8c9f0b0ac803329bc4d573969276e26">More...</a><br /></td></tr>
<tr class="separator:af8c9f0b0ac803329bc4d573969276e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958e3bc5a8cb8f7f3fd4f4abc4ea086e"><td class="memTemplParams" colspan="2">template&lt;typename GridView &gt; </td></tr>
<tr class="memitem:a958e3bc5a8cb8f7f3fd4f4abc4ea086e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00985.html#a958e3bc5a8cb8f7f3fd4f4abc4ea086e">writeToVTK</a> (const std::string &amp;fileName, const GridView &amp;gv) const</td></tr>
<tr class="memdesc:a958e3bc5a8cb8f7f3fd4f4abc4ea086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export random field as flat unstructured VTK file, requires dune-grid and dune-functions.  <a href="a00985.html#a958e3bc5a8cb8f7f3fd4f4abc4ea086e">More...</a><br /></td></tr>
<tr class="separator:a958e3bc5a8cb8f7f3fd4f4abc4ea086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4adfdc76b30547887487fc8dbfcfa6"><td class="memTemplParams" colspan="2">template&lt;typename GridView &gt; </td></tr>
<tr class="memitem:a3f4adfdc76b30547887487fc8dbfcfa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00985.html#a3f4adfdc76b30547887487fc8dbfcfa6">writeToVTKSeparate</a> (const std::string &amp;fileName, const GridView &amp;gv) const</td></tr>
<tr class="memdesc:a3f4adfdc76b30547887487fc8dbfcfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export random field as unstructured VTK file, requires dune-grid and dune-functions.  <a href="a00985.html#a3f4adfdc76b30547887487fc8dbfcfa6">More...</a><br /></td></tr>
<tr class="separator:a3f4adfdc76b30547887487fc8dbfcfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17090b8c11b5b80c798f8a3ecccad490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a17090b8c11b5b80c798f8a3ecccad490">writeToLegacyVTK</a> (const std::string &amp;fileName) const</td></tr>
<tr class="memdesc:a17090b8c11b5b80c798f8a3ecccad490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export random field as flat Legacy VTK file.  <a href="a00985.html#a17090b8c11b5b80c798f8a3ecccad490">More...</a><br /></td></tr>
<tr class="separator:a17090b8c11b5b80c798f8a3ecccad490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ed73bc2beda7397c9b0c333a7ded05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a17ed73bc2beda7397c9b0c333a7ded05">writeToLegacyVTKSeparate</a> (const std::string &amp;fileName) const</td></tr>
<tr class="memdesc:a17ed73bc2beda7397c9b0c333a7ded05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export random field as separate Legacy VTK entries.  <a href="a00985.html#a17ed73bc2beda7397c9b0c333a7ded05">More...</a><br /></td></tr>
<tr class="separator:a17ed73bc2beda7397c9b0c333a7ded05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b96197d802899d0ce1a481081f1da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a89b96197d802899d0ce1a481081f1da5">zero</a> ()</td></tr>
<tr class="memdesc:a89b96197d802899d0ce1a481081f1da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random field homogeneous.  <a href="a00985.html#a89b96197d802899d0ce1a481081f1da5">More...</a><br /></td></tr>
<tr class="separator:a89b96197d802899d0ce1a481081f1da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246acb8c1354738a26d7f6fe478c0d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a246acb8c1354738a26d7f6fe478c0d62">refineMatrix</a> ()</td></tr>
<tr class="memdesc:a246acb8c1354738a26d7f6fe478c0d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double spatial resolution of covariance matrix.  <a href="a00985.html#a246acb8c1354738a26d7f6fe478c0d62">More...</a><br /></td></tr>
<tr class="separator:a246acb8c1354738a26d7f6fe478c0d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33aaea505a3d44386c275972505d7f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ac33aaea505a3d44386c275972505d7f5">refine</a> ()</td></tr>
<tr class="memdesc:ac33aaea505a3d44386c275972505d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double spatial resolution of random field.  <a href="a00985.html#ac33aaea505a3d44386c275972505d7f5">More...</a><br /></td></tr>
<tr class="separator:ac33aaea505a3d44386c275972505d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f842099bcb7571131e5a5ade4d9483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a70f842099bcb7571131e5a5ade4d9483">coarsenMatrix</a> ()</td></tr>
<tr class="memdesc:a70f842099bcb7571131e5a5ade4d9483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce spatial resolution of covariance matrix.  <a href="a00985.html#a70f842099bcb7571131e5a5ade4d9483">More...</a><br /></td></tr>
<tr class="separator:a70f842099bcb7571131e5a5ade4d9483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7399498c6a010be4df5a6c7620bdc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a1a7399498c6a010be4df5a6c7620bdc2">coarsen</a> ()</td></tr>
<tr class="memdesc:a1a7399498c6a010be4df5a6c7620bdc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce spatial resolution of random field.  <a href="a00985.html#a1a7399498c6a010be4df5a6c7620bdc2">More...</a><br /></td></tr>
<tr class="separator:a1a7399498c6a010be4df5a6c7620bdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac085a01aafb8e6922192113b68f07e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html">RandomField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#aac085a01aafb8e6922192113b68f07e1">operator+=</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other)</td></tr>
<tr class="memdesc:aac085a01aafb8e6922192113b68f07e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator.  <a href="a00985.html#aac085a01aafb8e6922192113b68f07e1">More...</a><br /></td></tr>
<tr class="separator:aac085a01aafb8e6922192113b68f07e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142d4814a7bf8d5b52797228d3daf5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html">RandomField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a142d4814a7bf8d5b52797228d3daf5e2">operator-=</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other)</td></tr>
<tr class="memdesc:a142d4814a7bf8d5b52797228d3daf5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator.  <a href="a00985.html#a142d4814a7bf8d5b52797228d3daf5e2">More...</a><br /></td></tr>
<tr class="separator:a142d4814a7bf8d5b52797228d3daf5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67c5f84032ed67de53d48deb5bb780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html">RandomField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ade67c5f84032ed67de53d48deb5bb780">operator*=</a> (const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> alpha)</td></tr>
<tr class="memdesc:ade67c5f84032ed67de53d48deb5bb780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication with scalar.  <a href="a00985.html#ade67c5f84032ed67de53d48deb5bb780">More...</a><br /></td></tr>
<tr class="separator:ade67c5f84032ed67de53d48deb5bb780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfa5a414831a49f7e83dc75f985d63b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html">RandomField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#abcfa5a414831a49f7e83dc75f985d63b">axpy</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other, const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> alpha)</td></tr>
<tr class="memdesc:abcfa5a414831a49f7e83dc75f985d63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">AXPY scaled addition.  <a href="a00985.html#abcfa5a414831a49f7e83dc75f985d63b">More...</a><br /></td></tr>
<tr class="separator:abcfa5a414831a49f7e83dc75f985d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fabd4ca5b6a0d683a41bb7445d40edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html">RandomField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a0fabd4ca5b6a0d683a41bb7445d40edc">axpy</a> (const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> alpha, const <a class="el" href="a00985.html">RandomField</a> &amp;other)</td></tr>
<tr class="memdesc:a0fabd4ca5b6a0d683a41bb7445d40edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">AXPY scaled addition (swapped arguments)  <a href="a00985.html#a0fabd4ca5b6a0d683a41bb7445d40edc">More...</a><br /></td></tr>
<tr class="separator:a0fabd4ca5b6a0d683a41bb7445d40edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4835622bde636a26eb6cd557a17613cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a4835622bde636a26eb6cd557a17613cd">operator*</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other) const</td></tr>
<tr class="memdesc:a4835622bde636a26eb6cd557a17613cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product.  <a href="a00985.html#a4835622bde636a26eb6cd557a17613cd">More...</a><br /></td></tr>
<tr class="separator:a4835622bde636a26eb6cd557a17613cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9708eaa4de8e4bf57e12514f2a54da62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a9708eaa4de8e4bf57e12514f2a54da62">timesMatrix</a> ()</td></tr>
<tr class="memdesc:a9708eaa4de8e4bf57e12514f2a54da62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply random field with covariance matrix.  <a href="a00985.html#a9708eaa4de8e4bf57e12514f2a54da62">More...</a><br /></td></tr>
<tr class="separator:a9708eaa4de8e4bf57e12514f2a54da62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48215b9ad9835ae089d1e67038533e3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a48215b9ad9835ae089d1e67038533e3c">timesInverseMatrix</a> ()</td></tr>
<tr class="memdesc:a48215b9ad9835ae089d1e67038533e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply random field with inverse of covariance matrix.  <a href="a00985.html#a48215b9ad9835ae089d1e67038533e3c">More...</a><br /></td></tr>
<tr class="separator:a48215b9ad9835ae089d1e67038533e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1def6cb175416d3d9883ef978185a389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a1def6cb175416d3d9883ef978185a389">timesMatrixRoot</a> ()</td></tr>
<tr class="memdesc:a1def6cb175416d3d9883ef978185a389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply random field with approximate root of cov. matrix.  <a href="a00985.html#a1def6cb175416d3d9883ef978185a389">More...</a><br /></td></tr>
<tr class="separator:a1def6cb175416d3d9883ef978185a389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e655d6c07e258a283deac1044888107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a2e655d6c07e258a283deac1044888107">timesInvMatRoot</a> ()</td></tr>
<tr class="memdesc:a2e655d6c07e258a283deac1044888107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply random field with approximate inverse root of cov. matrix.  <a href="a00985.html#a2e655d6c07e258a283deac1044888107">More...</a><br /></td></tr>
<tr class="separator:a2e655d6c07e258a283deac1044888107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e2363cdab78dd39e684c733b9247f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a18e2363cdab78dd39e684c733b9247f7">oneNorm</a> () const</td></tr>
<tr class="memdesc:a18e2363cdab78dd39e684c733b9247f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-norm (sum of absolute values)  <a href="a00985.html#a18e2363cdab78dd39e684c733b9247f7">More...</a><br /></td></tr>
<tr class="separator:a18e2363cdab78dd39e684c733b9247f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486b2839c821c9d0cf2ee608c450d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a5486b2839c821c9d0cf2ee608c450d95">twoNorm</a> () const</td></tr>
<tr class="memdesc:a5486b2839c821c9d0cf2ee608c450d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean norm.  <a href="a00985.html#a5486b2839c821c9d0cf2ee608c450d95">More...</a><br /></td></tr>
<tr class="separator:a5486b2839c821c9d0cf2ee608c450d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab84c345282295faa89f59c5c5c0a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a0ab84c345282295faa89f59c5c5c0a7e">infNorm</a> () const</td></tr>
<tr class="memdesc:a0ab84c345282295faa89f59c5c5c0a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum norm.  <a href="a00985.html#a0ab84c345282295faa89f59c5c5c0a7e">More...</a><br /></td></tr>
<tr class="separator:a0ab84c345282295faa89f59c5c5c0a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a06bd26424632d1b74001099f40596c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a6a06bd26424632d1b74001099f40596c">operator==</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other) const</td></tr>
<tr class="memdesc:a6a06bd26424632d1b74001099f40596c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="a00985.html#a6a06bd26424632d1b74001099f40596c">More...</a><br /></td></tr>
<tr class="separator:a6a06bd26424632d1b74001099f40596c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9070bd10f26da66c7912358e6c4087"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a9d9070bd10f26da66c7912358e6c4087">operator!=</a> (const <a class="el" href="a00985.html">RandomField</a> &amp;other) const</td></tr>
<tr class="memdesc:a9d9070bd10f26da66c7912358e6c4087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="a00985.html#a9d9070bd10f26da66c7912358e6c4087">More...</a><br /></td></tr>
<tr class="separator:a9d9070bd10f26da66c7912358e6c4087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3223f9d6c89bcb387360ed267c478c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a3223f9d6c89bcb387360ed267c478c16">localize</a> (const typename <a class="el" href="a00989.html#af4edd3b08ecbdde3bc7cea5265213f18">Traits::DomainType</a> &amp;center, const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> radius)</td></tr>
<tr class="memdesc:a3223f9d6c89bcb387360ed267c478c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply field with Gaussian with given center and radius.  <a href="a00985.html#a3223f9d6c89bcb387360ed267c478c16">More...</a><br /></td></tr>
<tr class="separator:a3223f9d6c89bcb387360ed267c478c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a9517746032a6c08ef718295d2f11f8d0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a> = <a class="el" href="a00981.html">StochasticPart</a>&lt; <a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> &gt;</td></tr>
<tr class="separator:a9517746032a6c08ef718295d2f11f8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62019ffe63fc1d351c98a273991ad8ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> = typename <a class="el" href="a00989.html#aa48a30101b9db0873ac5ff04b5669553">Traits::RF</a></td></tr>
<tr class="separator:a62019ffe63fc1d351c98a273991ad8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fe06c492575861fc66a732bdf39a3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a21fe06c492575861fc66a732bdf39a3a">IsoMatrixPtr</a> = std::shared_ptr&lt; IsoMatrix&lt; <a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> &gt; &gt;</td></tr>
<tr class="separator:a21fe06c492575861fc66a732bdf39a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b32576213b4ef1a76019fb9139881"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#aa41b32576213b4ef1a76019fb9139881">AnisoMatrixPtr</a> = std::shared_ptr&lt; AnisoMatrix&lt; <a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> &gt; &gt;</td></tr>
<tr class="separator:aa41b32576213b4ef1a76019fb9139881"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab1f8a3166a349bf949555245e2e1f39c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01069.html">ParamTreeHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ab1f8a3166a349bf949555245e2e1f39c">treeHelper</a></td></tr>
<tr class="separator:ab1f8a3166a349bf949555245e2e1f39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65014826513fd13d3f3a82a89b25aef"><td class="memItemLeft" align="right" valign="top">const Dune::ParameterTree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ad65014826513fd13d3f3a82a89b25aef">config</a></td></tr>
<tr class="separator:ad65014826513fd13d3f3a82a89b25aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f40cf3a3947ec5cd9314775977edddb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01061.html">ValueTransform</a>&lt; <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a5f40cf3a3947ec5cd9314775977edddb">valueTransform</a></td></tr>
<tr class="separator:a5f40cf3a3947ec5cd9314775977edddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b01dd6548cb05787726589243c3871"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a63b01dd6548cb05787726589243c3871">traits</a></td></tr>
<tr class="separator:a63b01dd6548cb05787726589243c3871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ad62b94a3ca50161ea984a8467958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a21fe06c492575861fc66a732bdf39a3a">IsoMatrixPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a585ad62b94a3ca50161ea984a8467958">isoMatrix</a></td></tr>
<tr class="separator:a585ad62b94a3ca50161ea984a8467958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ad6ee119c8e41d9eb39e0bc8965553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#aa41b32576213b4ef1a76019fb9139881">AnisoMatrixPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a62ad6ee119c8e41d9eb39e0bc8965553">anisoMatrix</a></td></tr>
<tr class="separator:a62ad6ee119c8e41d9eb39e0bc8965553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194914170eda4500282c3b855e31e01e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a194914170eda4500282c3b855e31e01e">useAnisoMatrix</a></td></tr>
<tr class="separator:a194914170eda4500282c3b855e31e01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b18ac643bd60d4eac377b47a143970d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00969.html">TrendPart</a>&lt; <a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a3b18ac643bd60d4eac377b47a143970d">trendPart</a></td></tr>
<tr class="separator:a3b18ac643bd60d4eac377b47a143970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ce6b169608071982bd7ba3cc40fc3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a96ce6b169608071982bd7ba3cc40fc3f">stochasticPart</a></td></tr>
<tr class="separator:a96ce6b169608071982bd7ba3cc40fc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8f1019d0c2e4e16240614886df748"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ad1a8f1019d0c2e4e16240614886df748">cacheInvMatvec</a></td></tr>
<tr class="separator:ad1a8f1019d0c2e4e16240614886df748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487553c87bbd70497d788d05c0703d00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a487553c87bbd70497d788d05c0703d00">cacheInvRootMatvec</a></td></tr>
<tr class="separator:a487553c87bbd70497d788d05c0703d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee5336e7f3e466a05f7bedbe806ba6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a8fee5336e7f3e466a05f7bedbe806ba6">invMatvecPart</a></td></tr>
<tr class="separator:a8fee5336e7f3e466a05f7bedbe806ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97a5a82dca2f89ff8ab948ac500957a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#ad97a5a82dca2f89ff8ab948ac500957a">invRootMatvecPart</a></td></tr>
<tr class="separator:ad97a5a82dca2f89ff8ab948ac500957a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fada34428a039d6008db9ef20f8043f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#a2fada34428a039d6008db9ef20f8043f">invMatvecValid</a></td></tr>
<tr class="separator:a2fada34428a039d6008db9ef20f8043f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62a29b6b3d069c46df3e39c268eaa15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00985.html#aa62a29b6b3d069c46df3e39c268eaa15">invRootMatvecValid</a></td></tr>
<tr class="separator:aa62a29b6b3d069c46df3e39c268eaa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GridTraits, template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt;<br />
class parafields::RandomField&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;</h3>

<p>Gaussian random field in arbitrary dimensions. </p>
<p>The central class, representing stationary Gaussian random fields on a structured grid in arbitrary dimension. The underlying data types can be controlled using the GridTraits template parameter, one of several implementations of the circulant embedding technique can be chosen using the IsoMatrix and AnisoMatrix template template parameters, and options like the covariance function, correlation length, domain size, etc., can be controlled through the ParameterTree constructor argument. The constructor itself doesn't generate a field, you have to call the generate method to do that.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GridTraits</td><td>class defining dimension and data type of entries, etc. </td></tr>
    <tr><td class="paramname">IsoMatrix</td><td>covariance matrix implementation using underlying symmetries </td></tr>
    <tr><td class="paramname">AnisoMatrix</td><td>covariance matrix implementation for general covariance functions </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa41b32576213b4ef1a76019fb9139881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41b32576213b4ef1a76019fb9139881">&#9670;&nbsp;</a></span>AnisoMatrixPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html#aa41b32576213b4ef1a76019fb9139881">AnisoMatrixPtr</a> =  std::shared_ptr&lt;AnisoMatrix&lt;<a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21fe06c492575861fc66a732bdf39a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fe06c492575861fc66a732bdf39a3a">&#9670;&nbsp;</a></span>IsoMatrixPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html#a21fe06c492575861fc66a732bdf39a3a">IsoMatrixPtr</a> =  std::shared_ptr&lt;IsoMatrix&lt;<a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62019ffe63fc1d351c98a273991ad8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62019ffe63fc1d351c98a273991ad8ed">&#9670;&nbsp;</a></span>RF</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> =  typename <a class="el" href="a00989.html#aa48a30101b9db0873ac5ff04b5669553">Traits::RF</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9517746032a6c08ef718295d2f11f8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9517746032a6c08ef718295d2f11f8d0">&#9670;&nbsp;</a></span>StochasticPartType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a> =  <a class="el" href="a00981.html">StochasticPart</a>&lt;<a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acca23b257b56b7e0a750f0d3de85bb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca23b257b56b7e0a750f0d3de85bb8b">&#9670;&nbsp;</a></span>Traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a> =  <a class="el" href="a00989.html">RandomFieldTraits</a>&lt;GridTraits, IsoMatrix, AnisoMatrix&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a51200ef46e2f3ad0374f86d9b5b12b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51200ef46e2f3ad0374f86d9b5b12b1b">&#9670;&nbsp;</a></span>RandomField() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<div class="memtemplate">
template&lt;typename LoadBalance  = DefaultLoadBalance&lt;GridTraits::dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html">RandomField</a> </td>
          <td>(</td>
          <td class="paramtype">const Dune::ParameterTree &amp;&#160;</td>
          <td class="paramname"><em>config_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoadBalance &amp;&#160;</td>
          <td class="paramname"><em>loadBalance</em> = <code>LoadBalance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor reading from file or creating homogeneous field. </p>
<p>This constructor creates a homogeneous (i.e., constant) field if an empty string is passed as file name argument, and else tries to read a field from file. After successful construction you can call the generate method to generate a random field using circulant embedding, and repeat this process whenever you need a new random field.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LoadBalance</td><td>class used for parallel data distribution with MPI</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_</td><td>ParameterTree object containing configuration </td></tr>
    <tr><td class="paramname">fileName</td><td>name of file to read, empty string to not read anything </td></tr>
    <tr><td class="paramname">loadBalance</td><td>instance of the load balancer, if needed </td></tr>
    <tr><td class="paramname">comm</td><td>MPI communicator for parallel field generation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#ae81946963b8d1625f5733818bed4a3d6" title="Generate a field with the desired correlation structure.">generate</a> </dd></dl>

</div>
</div>
<a id="ac9fe6c63e1a77b60f7e94f6f9911561d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fe6c63e1a77b60f7e94f6f9911561d">&#9670;&nbsp;</a></span>RandomField() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<div class="memtemplate">
template&lt;typename LoadBalance  = DefaultLoadBalance&lt;GridTraits::dim&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html">RandomField</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoadBalance &amp;&#160;</td>
          <td class="paramname"><em>loadBalance</em> = <code>LoadBalance()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor reading field and config from file. </p>
<p>This constructor reads not only the field, but also its underlying parameters (i.e., the ParameterTree config object) from a file. This can be used to read in a field that was generated by another program run or another program altogether, and still have the correct parameterization available.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LoadBalance</td><td>class used for parallel data distribution with MPI</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>name of file to read (base name only) </td></tr>
    <tr><td class="paramname">loadBalance</td><td>instance of the load balancer, if needed </td></tr>
    <tr><td class="paramname">comm</td><td>MPI communicator for parallel field generation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#ae81946963b8d1625f5733818bed4a3d6" title="Generate a field with the desired correlation structure.">generate</a> </dd></dl>

</div>
</div>
<a id="a22cf1a4716435e0720ac1058eb4ee14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cf1a4716435e0720ac1058eb4ee14b">&#9670;&nbsp;</a></span>RandomField() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html">RandomField</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor copying traits and covariance matrix. </p>
<p>This constructor also reads a field from file, but reuses the configuration and covariance matrix from another field that has already been constructed. This avoids generating the same covariance matrix several times, saving memory when multiple fields have to be read in and subsequently modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field to copy most members from </td></tr>
    <tr><td class="paramname">fileName</td><td>name of file to read in (base name only)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#ae81946963b8d1625f5733818bed4a3d6" title="Generate a field with the desired correlation structure.">generate</a> </dd></dl>

</div>
</div>
<a id="ac6dabb17e572535d26dbaa329e222e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dabb17e572535d26dbaa329e222e69">&#9670;&nbsp;</a></span>RandomField() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::<a class="el" href="a00985.html">RandomField</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Standard copy constructor, creating a copy of a given random field, sharing the covariance matrix between all instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field that should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a06ea63a8f1baae4662baa090d81b3e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ea63a8f1baae4662baa090d81b3e29">&#9670;&nbsp;</a></span>add_trend_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::add_trend_components </td>
          <td>(</td>
          <td class="paramtype">const Dune::ParameterTree &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamically add trend components. </p>
<p>This adds trend components to an already instantiated random field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The configuration expecting the same input as the class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcfa5a414831a49f7e83dc75f985d63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfa5a414831a49f7e83dc75f985d63b">&#9670;&nbsp;</a></span>axpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">RandomField</a>&amp; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AXPY scaled addition. </p>
<p>Adds a multiple of another random field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field to add </td></tr>
    <tr><td class="paramname">alpha</td><td>scale factor for other field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to updated random field </dd></dl>

</div>
</div>
<a id="a0fabd4ca5b6a0d683a41bb7445d40edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fabd4ca5b6a0d683a41bb7445d40edc">&#9670;&nbsp;</a></span>axpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">RandomField</a>&amp; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AXPY scaled addition (swapped arguments) </p>
<p>Second version of scaled addition, with swapped arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field to add </td></tr>
    <tr><td class="paramname">alpha</td><td>scale factor for other field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to updated random field </dd></dl>

</div>
</div>
<a id="a8e76474a5b59ce685e5a8f26dadae6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e76474a5b59ce685e5a8f26dadae6e4">&#9670;&nbsp;</a></span>bulkEvaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::bulkEvaluate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; typename <a class="el" href="a00989.html#a15dfd27a422f62fc01e88ddb0e0e9906">Traits::RangeType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="a00989.html#a2826921d7c632bbfff497e3b51e480f1">Traits::Indices</a> &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the random field at all cells on this processor. </p>
<p>This function evaluates the random field on the entire grid that it is defined on. The result is stored in a linear container. The values are ordered such that the axes are in order x, y, z etc. Additionally, the function exports the sizes of the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>The output container of field values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sizes</td><td>The (local) sizes of the field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a929c32bce4c82ed36d4e09bc586f5441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929c32bce4c82ed36d4e09bc586f5441">&#9670;&nbsp;</a></span>cellVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::cellVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell volume of the random field discretization. </p>
<dl class="section return"><dt>Returns</dt><dd>volume of one of the grid cells the values are assigned to </dd></dl>

</div>
</div>
<a id="a1a7399498c6a010be4df5a6c7620bdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7399498c6a010be4df5a6c7620bdc2">&#9670;&nbsp;</a></span>coarsen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::coarsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce spatial resolution of random field. </p>
<p>Inverser operation to refine, merges cells by averaging their values. Just like refine, makes use of cached matrix-vector products if they are available.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#ac33aaea505a3d44386c275972505d7f5" title="Double spatial resolution of random field.">refine</a> </dd></dl>

</div>
</div>
<a id="a70f842099bcb7571131e5a5ade4d9483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f842099bcb7571131e5a5ade4d9483">&#9670;&nbsp;</a></span>coarsenMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::coarsenMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce spatial resolution of covariance matrix. </p>
<p>Inverse operation to refineMatrix, merging cells to build larger cells out of them, and then recomputing the covariance matrix.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#a246acb8c1354738a26d7f6fe478c0d62" title="Double spatial resolution of covariance matrix.">refineMatrix</a> </dd></dl>

</div>
</div>
<a id="adcbe8a51ea400b1a354a42d06ef6797f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbe8a51ea400b1a354a42d06ef6797f">&#9670;&nbsp;</a></span>dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of degrees of freedom. </p>
<p>This function returns the total number of degrees of freedom, i.e., summed across different processors, if applicable, and counting trend components.</p>
<dl class="section return"><dt>Returns</dt><dd>total degrees of freedom </dd></dl>

</div>
</div>
<a id="a6f04d48116cf25235548e9cb3936fe4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f04d48116cf25235548e9cb3936fe4c">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="a00989.html#af4edd3b08ecbdde3bc7cea5265213f18">Traits::DomainType</a> &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="a00989.html#a15dfd27a422f62fc01e88ddb0e0e9906">Traits::RangeType</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the random field at given coordinates. </p>
<p>This function evaluates the random field at the given coordinates, i.e., sums up the spatially distributed component and possible contributions from trend components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">location</td><td>coordinates where field should be evaluated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>field value at given position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9368238afb78bf7292007054ee89bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9368238afb78bf7292007054ee89bae">&#9670;&nbsp;</a></span>fillMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<div class="memtemplate">
template&lt;typename Covariance &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::fillMatrix </td>
          <td>(</td>
          <td class="paramtype">Covariance &amp;&amp;&#160;</td>
          <td class="paramname"><em>covariance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit matrix setup for custom covariance classes. </p>
<p>This function can be called if a custom user-supplied covariance function should be used. The function is passed as a callable (e.g. a (std::)function, a functor etc). In the configuration, "custom-iso" or "custom-aniso" has to be chosen as the desired covariance type. The former assumes that the covariance function is symmetric in each dimension, leading to significant memory savings, and will not work if that is not the case. </p>

</div>
</div>
<a id="ae81946963b8d1625f5733818bed4a3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81946963b8d1625f5733818bed4a3d6">&#9670;&nbsp;</a></span>generate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::generate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonWorldComm</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a field with the desired correlation structure. </p>
<p>Generate a random field sample based on the configured variance, covariance function, etc. By default, this function does not proceed if a non-World MPI communicator has been configured, because it would, e.g., silently generate different random fields on each of the equivalence classes defined by separate communicators. If you are sure that you want to do that (e.g., because you are running separate MCMC chains on different processors), you can pass true as an argument to disable the check.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowNonWorldComm</td><td>prevent inconsistent field generation by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c7ad192dd132719c589ddcea0105c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c7ad192dd132719c589ddcea0105c9">&#9670;&nbsp;</a></span>generate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::generate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonWorldComm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a field with desired correlation structure using seed. </p>
<p>Generate a random field sample, using a specific seed value for field generation. Note that you may still end up with different fields if you rerun with the same seed on different machines, or if you generate a field in parallel and the data distribution changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>seed value for random number generation </td></tr>
    <tr><td class="paramname">allowNonWorldComm</td><td>prevent inconsistent field generation by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa46b87d96023684d6929ba5c6dca8ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46b87d96023684d6929ba5c6dca8ff3">&#9670;&nbsp;</a></span>generateUncorrelated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::generateUncorrelated </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonWorldComm</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a field without correlation structure (i.e. noise) </p>
<p>This is a convenience function that generates white noise on the grid. Some applications require such white noise, and with this function it can be generated without defining a second type of random field, or applying circulant embedding for a case where it isn't actually needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allowNonWorldComm</td><td>prevent inconsistent field generation by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b09ed07a309172dbac18497994d9db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b09ed07a309172dbac18497994d9db8">&#9670;&nbsp;</a></span>generateUncorrelated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::generateUncorrelated </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonWorldComm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a field containing noise using seed. </p>
<p>This is a convenience function that generates white noise, based on a given seed value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>seed value for random number generation </td></tr>
    <tr><td class="paramname">allowNonWorldComm</td><td>prevent inconsistent field generation by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2ab19539c808298edf6e2325408ed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ab19539c808298edf6e2325408ed50">&#9670;&nbsp;</a></span>generateWithRNG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<div class="memtemplate">
template&lt;typename RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::generateWithRNG </td>
          <td>(</td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rngBackend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonWorldComm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a field with desired correlation structure using instantiate RNG. </p>
<p>Generate a random field sample, using a pre-instantiated RNG for field generation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rngBackend</td><td>The RNG providing a sample() method </td></tr>
    <tr><td class="paramname">allowNonWorldComm</td><td>prevent inconsistent field generation by default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ab84c345282295faa89f59c5c5c0a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab84c345282295faa89f59c5c5c0a7e">&#9670;&nbsp;</a></span>infNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::infNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum norm. </p>
<p>Returns the maximum value across both the spatially distributed values and the trend coefficients.</p>
<dl class="section return"><dt>Returns</dt><dd>resulting value </dd></dl>

</div>
</div>
<a id="a3223f9d6c89bcb387360ed267c478c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3223f9d6c89bcb387360ed267c478c16">&#9670;&nbsp;</a></span>localize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::localize </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="a00989.html#af4edd3b08ecbdde3bc7cea5265213f18">Traits::DomainType</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply field with Gaussian with given center and radius. </p>
<p>This is a helper function that dampens the random field except for a spherical region around a given location. The field is multiplied with a Gaussian with height one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>location of maximum of Gaussian </td></tr>
    <tr><td class="paramname">radius</td><td>scale parameter (standard deviation of Gaussian) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18e2363cdab78dd39e684c733b9247f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e2363cdab78dd39e684c733b9247f7">&#9670;&nbsp;</a></span>oneNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::oneNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One-norm (sum of absolute values) </p>
<p>Sums the absolute values of spatially distributed cell values and trend coefficients.</p>
<dl class="section return"><dt>Returns</dt><dd>resulting sum </dd></dl>

</div>
</div>
<a id="a9d9070bd10f26da66c7912358e6c4087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9070bd10f26da66c7912358e6c4087">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if operator== would return false, else false</dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator== </dd></dl>

</div>
</div>
<a id="a4835622bde636a26eb6cd557a17613cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4835622bde636a26eb6cd557a17613cd">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar product. </p>
<p>Scalar product of spatially distributed coefficients plus scalar product of trend coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field to multiply with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting scalar value </dd></dl>

</div>
</div>
<a id="ade67c5f84032ed67de53d48deb5bb780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade67c5f84032ed67de53d48deb5bb780">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">RandomField</a>&amp; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication with scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>scale factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to updated random field </dd></dl>

</div>
</div>
<a id="aac085a01aafb8e6922192113b68f07e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac085a01aafb8e6922192113b68f07e1">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">RandomField</a>&amp; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field that should be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to updated random field </dd></dl>

</div>
</div>
<a id="a142d4814a7bf8d5b52797228d3daf5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142d4814a7bf8d5b52797228d3daf5e2">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">RandomField</a>&amp; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field that should be subtracted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to updated random field </dd></dl>

</div>
</div>
<a id="a80ec552787cd55d6c28ac6006a66b395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ec552787cd55d6c28ac6006a66b395">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html">RandomField</a>&amp; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Standard assignment operator, sharing the covariance matrix between all instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field that should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a06bd26424632d1b74001099f40596c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a06bd26424632d1b74001099f40596c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00985.html">RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other random field to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all field values are the same, else false </dd></dl>

</div>
</div>
<a id="ac33aaea505a3d44386c275972505d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33aaea505a3d44386c275972505d7f5">&#9670;&nbsp;</a></span>refine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::refine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double spatial resolution of random field. </p>
<p>This function subdivides each cell in each dimension and interpolates the random field. If available, it uses the cached matrix-vector product, refines that instead, and multiplies with the new refined covariance matrix, which yields a smoother interpolation. </p>

</div>
</div>
<a id="a246acb8c1354738a26d7f6fe478c0d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246acb8c1354738a26d7f6fe478c0d62">&#9670;&nbsp;</a></span>refineMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::refineMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Double spatial resolution of covariance matrix. </p>
<p>This function instructs the covariance matrix to subdivide each cell in each dimension and recompute itself. It is not a part of the refine method for design reasons, since several random fields can share a covariance matrix, i.e., this method should only be called once, and then refine should be called on all fields sharing the matrix instance. </p>

</div>
</div>
<a id="afc300906c9a778530dda47cbd9fe0165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc300906c9a778530dda47cbd9fe0165">&#9670;&nbsp;</a></span>remove_trend_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::remove_trend_components </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamically remove a number of trend components. </p>
<p>This removes a number of trend components. We remove those that were added last.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of components to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48215b9ad9835ae089d1e67038533e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48215b9ad9835ae089d1e67038533e3c">&#9670;&nbsp;</a></span>timesInverseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::timesInverseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply random field with inverse of covariance matrix. </p>
<p>Multiplies the random field with the inverse of the covariance matrix, as is necessary in Bayesian inversion. Makes use of cached matrix-vector products if configured to do so and they are available. </p>

</div>
</div>
<a id="a2e655d6c07e258a283deac1044888107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e655d6c07e258a283deac1044888107">&#9670;&nbsp;</a></span>timesInvMatRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::timesInvMatRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply random field with approximate inverse root of cov. matrix. </p>
<p>Same as timesMatrixRoot, but with the inverse of the root, instead of the root itself. Introduces the same kind of boundary effects.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#a1def6cb175416d3d9883ef978185a389" title="Multiply random field with approximate root of cov. matrix.">timesMatrixRoot</a> </dd></dl>

</div>
</div>
<a id="a9708eaa4de8e4bf57e12514f2a54da62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9708eaa4de8e4bf57e12514f2a54da62">&#9670;&nbsp;</a></span>timesMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::timesMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply random field with covariance matrix. </p>
<p>Multiplies the random field with the covariance matrix, useful for Bayesian inversion. Caches the original field as the matrix-vector product of the resulting field with the inverse of the covariance matrix if configured to do so. This makes evaluating corresponding objective functions very cheap. </p>

</div>
</div>
<a id="a1def6cb175416d3d9883ef978185a389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1def6cb175416d3d9883ef978185a389">&#9670;&nbsp;</a></span>timesMatrixRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::timesMatrixRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply random field with approximate root of cov. matrix. </p>
<p>Multiplies the random field with an approximation of the root of the covariance matrix. The field is embedded in the extended circulant embedding domain, multiplied with the root of the extended covariance matrix (which is known exactly), and then restricted to the original domain. This introduces boundary effects, and therefore this matrix-vector product is not exact. </p>

</div>
</div>
<a id="a5486b2839c821c9d0cf2ee608c450d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5486b2839c821c9d0cf2ee608c450d95">&#9670;&nbsp;</a></span>twoNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::twoNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean norm. </p>
<p>Sums the squares of spatially distributed cell values and trend components, and returns the square root of the sum.</p>
<dl class="section return"><dt>Returns</dt><dd>resulting value </dd></dl>

</div>
</div>
<a id="af8c9f0b0ac803329bc4d573969276e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c9f0b0ac803329bc4d573969276e26">&#9670;&nbsp;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export random field to files on disk. </p>
<p>This function writes the random field, its trend components, and its configuration into files on disk, so that they can be made persistent and possibly read in again using the corresponding constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>base file name that should be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17090b8c11b5b80c798f8a3ecccad490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17090b8c11b5b80c798f8a3ecccad490">&#9670;&nbsp;</a></span>writeToLegacyVTK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::writeToLegacyVTK </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export random field as flat Legacy VTK file. </p>
<p>Same as writeToVTK, but writes a simple legacy VTK format and doesn't depend on dune-grid and dune-functions. Unfortunately, this function doesn't work for parallel runs, only for sequential field creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file name for VTK output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#a958e3bc5a8cb8f7f3fd4f4abc4ea086e" title="Export random field as flat unstructured VTK file, requires dune-grid and dune-functions.">writeToVTK</a> </dd></dl>

</div>
</div>
<a id="a17ed73bc2beda7397c9b0c333a7ded05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ed73bc2beda7397c9b0c333a7ded05">&#9670;&nbsp;</a></span>writeToLegacyVTKSeparate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::writeToLegacyVTKSeparate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export random field as separate Legacy VTK entries. </p>
<p>Same as writeToVTKSeparate, but writes a simple legacy VTK format and doesn't depend on dune-grid and dune-functions. Unfortunately, this function doesn't work for parallel runs, only for sequential field creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file name for VTK output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00985.html#a958e3bc5a8cb8f7f3fd4f4abc4ea086e" title="Export random field as flat unstructured VTK file, requires dune-grid and dune-functions.">writeToVTK</a> </dd></dl>

</div>
</div>
<a id="a958e3bc5a8cb8f7f3fd4f4abc4ea086e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958e3bc5a8cb8f7f3fd4f4abc4ea086e">&#9670;&nbsp;</a></span>writeToVTK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<div class="memtemplate">
template&lt;typename GridView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::writeToVTK </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridView &amp;&#160;</td>
          <td class="paramname"><em>gv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export random field as flat unstructured VTK file, requires dune-grid and dune-functions. </p>
<p>This function writes the whole random field to a VTK file, i.e., the sum of the spatially distributed part and all present trend components. These are the same values as returned by evaluate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file name for VTK output </td></tr>
    <tr><td class="paramname">gv</td><td>Dune GridView defining the grid used in the VTK file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4adfdc76b30547887487fc8dbfcfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4adfdc76b30547887487fc8dbfcfa6">&#9670;&nbsp;</a></span>writeToVTKSeparate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<div class="memtemplate">
template&lt;typename GridView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::writeToVTKSeparate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridView &amp;&#160;</td>
          <td class="paramname"><em>gv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export random field as unstructured VTK file, requires dune-grid and dune-functions. </p>
<p>This function writes the individual components of the random field to a VTK file, i.e., the spatially distributed part and all present trend components each as a separate data set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>file name for VTK output </td></tr>
    <tr><td class="paramname">gv</td><td>Dune GridView defining the grid used in the VTK file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b96197d802899d0ce1a481081f1da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b96197d802899d0ce1a481081f1da5">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make random field homogeneous. </p>
<p>This function sets both the field values and the trend coefficients to zero, creating a field that represents a constant function with value zero. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a62ad6ee119c8e41d9eb39e0bc8965553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ad6ee119c8e41d9eb39e0bc8965553">&#9670;&nbsp;</a></span>anisoMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#aa41b32576213b4ef1a76019fb9139881">AnisoMatrixPtr</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::anisoMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1a8f1019d0c2e4e16240614886df748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a8f1019d0c2e4e16240614886df748">&#9670;&nbsp;</a></span>cacheInvMatvec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::cacheInvMatvec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a487553c87bbd70497d788d05c0703d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487553c87bbd70497d788d05c0703d00">&#9670;&nbsp;</a></span>cacheInvRootMatvec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::cacheInvRootMatvec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad65014826513fd13d3f3a82a89b25aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65014826513fd13d3f3a82a89b25aef">&#9670;&nbsp;</a></span>config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Dune::ParameterTree <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fee5336e7f3e466a05f7bedbe806ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee5336e7f3e466a05f7bedbe806ba6">&#9670;&nbsp;</a></span>invMatvecPart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a>&gt; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::invMatvecPart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fada34428a039d6008db9ef20f8043f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fada34428a039d6008db9ef20f8043f">&#9670;&nbsp;</a></span>invMatvecValid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::invMatvecValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad97a5a82dca2f89ff8ab948ac500957a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97a5a82dca2f89ff8ab948ac500957a">&#9670;&nbsp;</a></span>invRootMatvecPart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a>&gt; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::invRootMatvecPart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa62a29b6b3d069c46df3e39c268eaa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62a29b6b3d069c46df3e39c268eaa15">&#9670;&nbsp;</a></span>invRootMatvecValid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::invRootMatvecValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a585ad62b94a3ca50161ea984a8467958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585ad62b94a3ca50161ea984a8467958">&#9670;&nbsp;</a></span>isoMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a21fe06c492575861fc66a732bdf39a3a">IsoMatrixPtr</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::isoMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96ce6b169608071982bd7ba3cc40fc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ce6b169608071982bd7ba3cc40fc3f">&#9670;&nbsp;</a></span>stochasticPart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00985.html#a9517746032a6c08ef718295d2f11f8d0">StochasticPartType</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::stochasticPart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b01dd6548cb05787726589243c3871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b01dd6548cb05787726589243c3871">&#9670;&nbsp;</a></span>traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a>&gt; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::traits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1f8a3166a349bf949555245e2e1f39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f8a3166a349bf949555245e2e1f39c">&#9670;&nbsp;</a></span>treeHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01069.html">ParamTreeHelper</a> <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::treeHelper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b18ac643bd60d4eac377b47a143970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b18ac643bd60d4eac377b47a143970d">&#9670;&nbsp;</a></span>trendPart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00969.html">TrendPart</a>&lt;<a class="el" href="a00985.html#acca23b257b56b7e0a750f0d3de85bb8b">Traits</a>&gt; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::trendPart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a194914170eda4500282c3b855e31e01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194914170eda4500282c3b855e31e01e">&#9670;&nbsp;</a></span>useAnisoMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::useAnisoMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f40cf3a3947ec5cd9314775977edddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f40cf3a3947ec5cd9314775977edddb">&#9670;&nbsp;</a></span>valueTransform</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridTraits , template&lt; typename &gt; class IsoMatrix = DefaultIsoMatrix&lt;GridTraits::dim&gt;::template Type, template&lt; typename &gt; class AnisoMatrix = DefaultAnisoMatrix&lt;GridTraits::dim&gt;::template Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01061.html">ValueTransform</a>&lt;<a class="el" href="a00985.html#a62019ffe63fc1d351c98a273991ad8ed">RF</a>&gt; <a class="el" href="a00985.html">parafields::RandomField</a>&lt; GridTraits, IsoMatrix, AnisoMatrix &gt;::valueTransform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00035_source.html">fieldtraits.hh</a></li>
<li><a class="el" href="a00059_source.html">randomfield.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
